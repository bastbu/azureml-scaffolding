#!/usr/bin/env bash
#? Isolate artifacts for an package run in a separate directory

set -eo pipefail
cd "$(dirname "$0")/../.."

function usage {
    cat<<EOF
Isolate artifacts for an package run in a separate directory

Usage: $0 PACKAGE RUN_NAME

Options:
    -h, --help            Show this help message and exit

Arguments:
  PACKAGE     Directory of the package relative to "$PKGS_PATH"
  RUN_NAME    Name of the run

The goal is to isolate the absolute minimum to run a package. This aims to
make the run reproducible and portable as well as easy to reason about in
the future.

The run directory will be created in "$RUNS_PATH/PACKAGE/RUN_NAME".
The run directory will contain all files inside PACKAGE and will
add the 'shared' code and the environment files. Thus, the final structure:
  <run_name>
  ├── .amlignore
  ├── azure-ml-job.yaml
  ├── shared/
  ├── tests/
  ├── environment/
  │   ├── Dockerfile
  │   └── requirements.txt
  └── <package>
      ├── __main__.py
      └── ...

The requirements.txt will contain only the dependencies specified for the
package.
EOF
}

bin/chkenv "PKGS_PATH" "RUNS_PATH"

while :; do
    case $1 in
        -h|--help) usage; exit ;;
        *) break ;;
    esac
    shift
done

if [ $# -ne 2 ]; then
    echo>&2 "Both PACKAGE and RUN_NAME required."
    usage>&2
    exit 1
fi

package=$1
run_name=$2
if [[ ! -d "$PKGS_PATH/$package" ]]; then
    echo>&2 "Package directory '$PKGS_PATH/$package' does not exist."
    exit 1
fi

# create run directory
run_dir="$RUNS_PATH/$package/$run_name"
mkdir -p "$run_dir"

# copy package code and common code to run directory
cp -r "$PKGS_PATH/$package/src/." "$run_dir"
cp -r "$PKGS_PATH/shared/src/shared" "$run_dir"

# copy artifacts to build environment
docker_context="$run_dir/environment"
mkdir -p "$docker_context"
uv export --quiet \
    --output-file "$docker_context/requirements.txt" \
    --package "$package" \
    --no-hashes \
    --no-emit-workspace

# run directory to stdout so it can be used by other scripts
echo "$run_dir"